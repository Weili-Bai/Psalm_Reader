/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>
#include <ctype.h>
#include "Contents.h"
#include "Peripheral.h"
#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif
const int SIZE=4;
void activateInput(GPIOxMode_t*reg){
	reg->pin8=0;
	reg->pin9=0;
	reg->pin10=0;
	reg->pin11=0;
}
void activateOutput(GPIOxMode_t*reg){
	reg->pin0=1;
	reg->pin1=1;
	reg->pin2=1;
	reg->pin3=1;
}
void outputHigh(GPIOxIO_t* outputReg){
	outputReg->pin0=1;
	outputReg->pin1=1;
	outputReg->pin2=1;
	outputReg->pin3=1;
}
char detectKey(uint8_t row, uint8_t col){
	if(row == 1 && col == 1)
		return '1';
	if(row == 1 && col == 2)
		return '2';
	if(row == 1 && col == 3)
		return '3';
	if(row == 1 && col == 4)
		return 'A';
	if(row == 2 && col == 1)
		return '4';
	if(row == 2 && col == 2)
		return '5';
	if(row == 2 && col == 3)
		return '6';
	if(row == 2 && col == 4)
		return 'B';
	if(row == 3 && col == 1)
		return '7';
	if(row == 3 && col == 2)
		return '8';
	if(row == 3 && col == 3)
		return '9';
	if(row == 3 && col == 4)
		return 'C';
	if(row == 4 && col == 1)
		return '*';
	if(row == 4 && col == 2)
		return '0';
	if(row == 4 && col == 3)
		return '#';
	if(row == 4 && col == 4)
		return 'D';
	return ' ';
}
uint8_t getColLow(GPIOxIO_t* inputReg){
	if(inputReg->pin8==0)
		return 1;
	if(inputReg->pin9==0)
		return 2;
	if(inputReg->pin10==0)
		return 3;
	if(inputReg->pin11==0)
		return 4;
	return 0;
}
void makeR1Low(GPIOxIO_t* outputReg){
	outputReg->pin0=0;
	outputReg->pin1=1;
	outputReg->pin2=1;
	outputReg->pin3=1;
}
void makeR2Low(GPIOxIO_t* outputReg){
	outputReg->pin0=1;
	outputReg->pin1=0;
	outputReg->pin2=1;
	outputReg->pin3=1;
}
void makeR3Low(GPIOxIO_t* outputReg){
	outputReg->pin0=1;
	outputReg->pin1=1;
	outputReg->pin2=0;
	outputReg->pin3=1;
}
void makeR4Low(GPIOxIO_t* outputReg){
	outputReg->pin0=1;
	outputReg->pin1=1;
	outputReg->pin2=1;
	outputReg->pin3=0;
}
void pullupInput(GPIOxMode_t* pullup){
	pullup->pin8=1;
	pullup->pin9=1;
	pullup->pin10=1;
	pullup->pin11=1;
}
void initializeUserInput(char input[]){
	for(int i=0;i<SIZE;i++){
		input[i]='\0';
	}
}
void getChapterArr(char userInput[]){
	RCC_AHB1_EN_t*pRccMode=(RCC_AHB1_EN_t*)0x40023830;
	pRccMode->GPIOD=1;
	GPIOxMode_t* pDMode=(GPIOxMode_t*)0x40020c00;
	GPIOxIO_t*pDOutput=(GPIOxIO_t*)0x40020c14;
	GPIOxIO_t*pDInput=(GPIOxIO_t*)0x40020c10;
	GPIOxMode_t*pPullUp=(GPIOxMode_t*)0x40020c0C;
	pullupInput(pPullUp);
	uint8_t colNum=0;
	uint8_t index=0;
	initializeUserInput(userInput);
	printf("Please enter a valid chapter number (from 1 to %d).\n",MAX_CHAPTER );
	printf("Press\'#\' to enter or \'*\' to backspace.\n");
	while(1){
		if(index>2)
			break;
		activateInput(pDMode);
		activateOutput(pDMode);
		outputHigh(pDOutput);
		colNum=0;
		makeR1Low(pDOutput);
		colNum=getColLow(pDInput);
		if(colNum!=0){
			for(volatile int i = 0; i<600000;i++){}
			char key = detectKey(1,colNum);
			userInput[index++]=key;
			printf("%s\n",userInput);
		}
		makeR2Low(pDOutput);
		colNum=0;

		colNum=getColLow(pDInput);
		if(colNum!=0){
			for(volatile int i = 0; i<600000;i++){}
			char key = detectKey(2,colNum);
			userInput[index++]=key;
			printf("%s\n",userInput);
			}

			colNum=0;
			makeR3Low(pDOutput);
			colNum=getColLow(pDInput);
			if(colNum!=0){
				for(volatile int i = 0; i<600000;i++){}
				char key = detectKey(3,colNum);
				userInput[index++]=key;
				printf("%s\n",userInput);
			}

			colNum=0;
			makeR4Low(pDOutput);
			colNum=getColLow(pDInput);
			if(colNum!=0){
				for(volatile int i = 0; i<600000;i++){}
				char key = detectKey(4,colNum);
				if(key=='*'){
					index--;
					if(index<0){
						index=0;
					}
				}
				else if(key=='#'){
					break;
				}
				else{
					userInput[index++]=key;
					printf("%s\n",userInput);
				}
			}
		}
}
unsigned int getChapterNum(char userInput[]){
	unsigned int result=0;
	for(int i=0;i<SIZE&&userInput[i]!='\0';i++){
		char ch=userInput[i];
		if(!isdigit(ch))
			return 0;
		result+=(ch-'0');
		result*=10;
	}
	result/=10;
	return result;
}
int validateChapterNum(unsigned int num){
	return num>0&&num<151;
}void initPsalm() {
    psalm[0] = cha0;
    psalm[1] = cha1;
    psalm[2] = cha2;
}
int main(void)
{
	char userInput[SIZE];
	unsigned int chapterNum=0;
	int isValid=0;
	while(!isValid){
		getChapterArr(userInput);
		chapterNum=getChapterNum(userInput);
		isValid=validateChapterNum(chapterNum);
		if(!isValid){
			printf("Invalid chapter number!\n");
		}
	}
	initPsalm();
	printf("%s",psalm[chapterNum]);
	while(1){}
	return 0;
}
